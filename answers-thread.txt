Because at first, there is no mutex lock to protect the both-shared memory of the two threads. Under such circumstance, supposing that a thread A and a thread B are currently calling get_thread() to append new keys to the chain of table[i](0<i<4) by chance. Supposing that A and B are going to append different values tothe same key(here we call it C), and supposing that A and B almost have the targeted key's address at the same time(i.e. they both get C's adrress).If A finishes the appending process earlier than B, A firstly will append the new created key to C. But when B's appending process has finished, B will also append B's new created key to C(i.e. the original A-created-key will be covered by B-created-key),resulting in key missing.
