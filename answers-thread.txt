因为一开始并没有互斥锁来保护两个线程的共享内存。假设线程A和线程B当前正在同时调用gut_thread()函数、并恰好需要向同一个entry e的后面附加不同的entry。如果A和B几乎是同时获得entry e的地址，且A比B更早完成附加过程。那么，A会将新创建的entry附加到entry e后面。但是，因为B线程拿到的也是entry e的地址、而不是A新创建的entry的地址。因此，当B的附加过程完成时，B也会将B新创建的entry附加到entry e后面，而不是A新创建的entry后面（即，A创建的entry将被B创建的entry覆盖），从而导致key丢失。